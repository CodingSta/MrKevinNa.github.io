---
title: "기초 통계 정리"
author: "Dr.Kevin"
date: '2/4/2018'
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '750px', dpi = 300)
```

R을 활용한 기초 통계와 통계량을 구하는 방법에 대해 간단하게 살펴보겠습니다.
1. 데이터의 정규성을 확인합니다. 일부 알고리즘의 경우, 데이터의 정규분포를 가정하기 때문입니다.  
1. 최소값/최대값, 분위수, 중앙값, 평균, 분산, 표준편차 등 기초 통계량을 구해봅니다.  
1. 도수분포표를 만듭니다. 데이터를 일정 구간으로 나누고, 구간별 빈도수와 상대도수 및 누적상대도수를 추가합니다.  
1. 상자수염그림(Box plot)을 그리고 이상치를 확인합니다. 필요 시 NA로 변환하거나 삭제합니다.  
1. 히스토그램(Histgram)을 그려봅니다.  
1. 산점도(Scatter plot)를 그려봅니다.  

### 정규성 테스트

회귀분석과 같은 알고리즘의 경우, 종속변수나 오차에 대해 정규분포를 가정하고 있으므로 분석 모델링을 하기에 앞서 데이터의 분포를 확인할 필요가 있습니다.

```{r}
# 임의의 수를 생성할 때, 항상 같은 결과를 얻기 위해 set.seed() 설정
set.seed(seed = 123)

# 평균이 0, 표준편차가 1인 정규분포를 따르는 임의의 수를 1000개 생성
# x 객체 할당
x <- rnorm(n = 1000, mean = 0, sd = 1)
```

#### 그래프로 확인하는 방법

자료의 정규성을 그래프로 확인하는 방법은 **히스토그램**과 **Normal QQ-Plot**을 그려보는 방법이 있습니다. 히스토그램은 다음과 같이 그릴 수 있습니다.

```{r}
# R studio에서 한글 사용
par(family = "NanumGothic")

# 히스토그램을 그려 x의 분포 확인
hist(x = x, 
     breaks = 10, 
     probability = TRUE, 
     main = "히스토그램 예제", 
     family = "NanumGothic")

# 히스트그램 위에 x의 확률밀도함수 추가
lines(x = density(x), col = "red")
```

이번에는 Normal QQ-plot을 그려보겠습니다.

```{r}
# 직선인 경우, 정규분포 가정
qqnorm(y = x)
```

#### 통계적 유의성 검정 방법

자료의 정규성을 통계적 유의성 검정을 통해 확인하는 방법은 **Shapiro-Wilk 테스트**와 **Anderson-Darling 테스트**가 있습니다. 이 두 가지 검증의 귀무가설은 **정규분포한다**입니다. 따라서 p-value가 0.05보다 작으면 95% 유의수준 하에서 귀무가설을 기각할 수 있습니다.

```{r}
# Shapiro-Wilk test
library(stats)
shapiro.test(x = x)
```

```{r}
# Anderson-Darling test
library(nortest)
ad.test(x = x)
```

이번 예제를 위해 임의로 생성한 `x` 데이터로 두 가지 검증을 실행한 결과, 모두 p-value가 0.05보다 크므로 귀무가설을 기각할 수 없습니다. 따라서 **x는 정규분포한다**고 할 수 있습니다. 

#### 첨도(Kurtosis)와 왜도(Skewness) 확인

데이터가 정규분포를 따르면 확률밀도함수는 종모양으로 그려집니다. 이 때, 중심이 뾰족한 정도는 **첨도**로, 꼬리가 한 쪽으로 치우친 비대칭 정도는 **왜도**를 구해 확인할 수 있습니다. 아래에 제시한 함수로 첨도와 왜도를 계산하는 경우, 첨도와 왜도는 0에 가까울수록 정규분포로 추정할 수 있습니다.

```{r}
library(e1071)

# 첨도 계산
# 0보다 작으면 완만하고, 0보다 크면 뾰족
kurtosis(x = x)

# 왜도 계산
# 0보다 작으면 왼쪽 꼬리가 길고, 0보다 크면 오른쪽 꼬리가 김
skewness(x = x)
```

## 기초 통계량 구하기

1. 최소값(0%), 최대값(100%), 범위  
1. 중앙값(50%)  
1. 평균  
1. 사분위수 : 최소값, 1분위수(25%), 중앙값, 평균, 3분위수(75%), 최대값  
1. 사분범위(IQR) : 3분위수와 1분위수 간 차이  
1. 분산과 표준편차  

```{r}
# 최소값 : min()
cat("최소값 :", round(x = min(x), digits = 3), "\n")

# 중앙값: median()
cat("중앙값 :", round(x = median(x), digits = 3), "\n")

# 평균 : mean()
cat("평균   :", round(x = mean(x), digits = 3), "\n")

# 최대값 : max()
cat("최대값 :", round(x = max(x), digits = 3), "\n")

# 범위 : range(), 최소값과 최대값을 한 번에 출력
cat("범위   :", round(x = range(x), digits = 3), "\n")

# 분위수 : quantile()
cat("분위수 :", round(x = quantile(x), digits = 3), "\n")
```

다음과 같이 하면 사용자가 임의로 분위수 `%`를 설정할 수 있습니다.

```{r}
# 임의로 분위수의 % 설정하기
qntl <- round(x = quantile(x = x, 
                           probs = c(0, 0.05, 0.1, 0.9, 0.95, 1)),
              digits = 3)
print(qntl)
```

`summary()` 함수를 이용하면 위에서 언급된 숫자형 데이터의 요약 통계량들을 쉽게 확인할 수 있습니다. 문자형 데이터라면 각 문자별 빈도수를 출력합니다. 

```{r}
# 숫자형 데이터의 요약 통계량 간단 확인
summary(object = x)
```

이번에는 분산과 표준편차를 구하는 방법을 알아보겠습니다. 분산과 표준편차는 데이터가 얼마나 퍼져 있는지를 알아보기 위해 사용합니다. 한 가지 유의해야 할 점은 표본의 분산은 `n`이 아닌 `n-1`로 나누어 주어야 한다는 것입니다. 그리고 표준편차는 분산의 양의 제곱근입니다.

```{r}
# 분산 
cat("분산 :", round(x = var(x), digits = 4), "\n")

# 표준편차
cat("표준편차 :", round(x = sd(x), digits = 4), "\n")
```

```{r}
# [참고] 숫자형 데이터의 기술(descriptive) 통계량을 한 번에 확인
psych::describe(x = x)
```

위에서 열거한 기초 통계량을 한 번에 확인할 수 있도록 사용자 정의 함수를 만들어 보겠습니다. 그리고 임의의 수를 생성하여 사용자 정의 함수를 실행해보겠습니다.

```{r}
# 기초 통계량을 반환하는 사용자 정의 함수 생성
myStats <- function(obj) {
    cat("최소값   :", round(x = min(obj), digits = 3), "\n")
    cat("1분위수  :", round(x = quantile(obj)[2], digits = 3), "\n")
    cat("중앙값   :", round(x = median(obj), digits = 3), "\n")
    cat("평균     :", round(x = mean(obj), digits = 3), "\n")
    cat("3분위수  :", round(x = quantile(obj)[4], digits = 3), "\n")
    cat("최대값   :", round(x = max(obj), digits = 3), "\n")
    cat("분산     :", round(x = var(obj), digits = 3), "\n")
    cat("표준편차 :", round(x = sd(obj), digits = 3), "\n")
}

# set.seed() 설정
set.seed(seed = 123)

# 평균이 10, 표준편차가 5인 정규분포를 따르는 임의의 수 100개 생성
y <- rnorm(n = 100, mean = 10, sd = 5)

# 사용자 정의 함수에 y를 할당하고 실행
myStats(y)
```

## 상자 수염 그림 (Box plot)

상자 수염 그림은 숫자형 데이터의 요약 수치를 한 눈에 알아볼 수 있는 그래프입니다.

![상자수엽그림](http://cfile27.uf.tistory.com/image/2774654A52CE9A3618B7B3)

* 출처 : http://analyticsstory.com/72

```{r}
# 상자수염그림
boxplot(x = y)
```

상자수염그림으로 데이터의 이상치(outlier)를 확인할 수 있습니다. 이상치 설명을 위해 임의로 이상치를 추가하겠습니다.

```{r}
# 테스트용 이상치를 벡터 y 앞 뒤로 2개씩 추가
y <- c(c(-12, -10), y, c(32, 34))
boxplot(x = y)
```

이상치 기준값을 산정할 때, IQR(interquantile range)을 사용할 수 있습니다. IQR은 1분위수와 3분위수 사이의 범위를 의미합니다. 이상치는 1분위수에서 IQR의 1.5배보다 낮은 값 또는 3분위수에서 IQR의 1.5배보다 큰 값으로 정할 수 있습니다. 

```{r}
# 사분범위(IQR)
iqrY <- IQR(x = y)
print(iqrY)

# 사분위수 구하기
quntY <- quantile(x = y)
print(quntY)
```

```{r}
# 이상치 기준값 : 1분위수에서 IQR의 1.5배보다 작은 값 또는 3분위수에서 IQR의 1.5배보다 큰 값

# 벡터 y의 개별 값이 아래 조건식을 만족하는지 여부에 따라서 TRUE 또는 FALSE로 출력됩니다. 
out1 <- quntY[2] - iqrY * 1.5
out2 <- quntY[4] + iqrY * 1.5

cat("이상치 기준점 1 :", out1, "\n")
cat("이상치 기준점 2 :", out2, "\n")

# 이상치인 판정된 값을 출력합니다. 
y[y < out1 | y > out2]

# 벡터 y에서 이상치의 위치를 출력합니다. 
loc <- which(y < out1 | y > out2)
print(loc)

# 벡터 y에서 이상치를 NA로 변경합니다. 
y[loc] <- NA
print(y)
```

이상치를 삭제합니다. 

```{r}
# 이상치를 삭제합니다.
y1 <- y[complete.cases(y)]
length(y1)

y2 <- y[is.na(y) == FALSE]
length(y2)

# 두 객체의 교집합의 길이를 확인합니다. 
length(x = intersect(x = y1, y = y2))
```

이상치를 찾는 더 쉬운 방법은 boxplot.stats() 함수를 이용하는 것입니다. 

```{r}
set.seed(seed = 123)
y <- rnorm(n = 100, mean = 10, sd = 5)
y <- c(c(-12, -10), y , c(32, 34))

# boxplot.stats() 함수의 결과 객체 중 out이 이상치를 제공합니다. 
boxplot.stats(x = y)

# 이상치를 NA로 변경한 후 삭제합니다. 
y[y == boxplot.stats(y)$out] <- NA
print(y)

y <- y[complete.cases(y)]
length(x = y)
```

## 표준화 vs 정규화
* 표준화(Standardization)와 정규화(Normalization)는 숫자형 데이터가 일정한 분포를 갖도록 변환하는 것을 의미합니다. 
* 척도가 서로 다른 2개 이상의 숫자형 데이터를 그대로 사용하는 경우, 분석 모형이 각각의 척도에 영향을 받게 됩니다. 
* 또한 인공신경망처럼 입력값이 0~1 사이의 값으로 요구되는 경우는 반드시 정규화를 해주어야 합니다. 
* 표준화는 평균과 표준편차를 이용하여 변환하며, 표준화된 데이터(Z)는 -Inf과 Inf 사이의 값을 가집니다. 
    - x는 원본 데이터, μ는 x의 평균, σ는 x의 표준편차
$$ Z = \frac {x - \mu} \sigma $$
* 정규화는 0과 1 사이의 값을 갖도록 조정하는 것을 의미하며, 다양한 방법이 있으나 주로 최소값과 최대값을 이용하여 변환합니다.
    - x는 원본 데이터, min은 x의 최소값, max는 x의 최대값
$$ x_{new} = \frac {x - min} {max - min} $$

```{r}
# 난수를 생성하기 전에 set.seed()를 지정합니다. 
set.seed(seed = 1)

# 1부터 1000의 값을 가지는 숫자형 벡터를 만들고, 그 중 500개를 임의로 선택하여 a 객체에 할당합니다.
a <- sample(x = 1:1000, size = 500, replace = FALSE, prob = NULL)
myStats(a)

# 평균이 0, 표준편차가 1인 데이터로 표준화합니다. 
scaledA1 <- scale(x = a, center = mean(a), scale = sd(a))
myStats(scaledA1)

# 최소값이 0, 최대값이 1인 데이터로 정규화합니다. 
scaledA2 <- scale(x = a, center = min(a), scale = (max(a) - min(a)))
myStats(scaledA2)
```

## 도수분포표 만들기
* 주어진 자료를 몇 개의 구간으로 나누고, 해당 구간에 속하는 자료의 개수(빈도수)를 구합니다.
* 빈도수에 상응하는 상대도수를 추가합니다. 
* 빈도수와 상대도수의 합계를 구하여 추가합니다. 

```{r}
# 가상의 몸무게 데이터를 만듭니다.
set.seed(seed = 123)
weights <- rnorm(n = 100, mean = 70, sd = 10)
weights <- round(x = weights, digits = 1)

# 기초 통계량을 확인합니다.
myStats(weights)

# 5kg 단위로 구간을 만들고, 빈도수를 구합니다.
# Hmisc::cut2() 함수의 minmax 인자는 최소값 또는 최대값을 포함할지 여부를 지정! 
cuts <- seq(from = 45, to = 90, by = 5)
weightsCuts <- Hmisc::cut2(x = weights, cuts = cuts, minmax = TRUE)
weightsTb <- table(weightsCuts)
print(weightsTb)

# 각 구간별 상대도수를 구한 후, 도수분포표에 추가합니다.
weightsPr <- prop.table(x = weightsTb, margin = NULL)
weightsTb <- rbind(weightsTb, weightsPr)
print(weightsTb)

# 각 구간별 누적상대도수를 구한 후, 도수분포표에 추가합니다.
weightsCm <- cumsum(x = weightsPr)
weightsTb <- rbind(weightsTb, weightsCm)
print(weightsTb)

# 행별 합계를 구한 후, 도수분포표에 추가합니다.
weightsTb <- addmargins(A = weightsTb, margin = 2, FUN = sum)
print(weightsTb)

# 행과 열의 이름을 변경합니다.
rownames(weightsTb) <- c("빈도수(명)", "상대도수(%)", "누적상대도수(%)")
colnames(weightsTb) <- c("45~50kg", "50~55kg", "55~60kg", "60~65kg", "65~70kg",
                         "70~75kg", "75~80kg", "80~85kg", "85~90kg", "90kg이상", "합계")
print(weightsTb)
```

## 히스토그램 그리기 (Histogram)
> hist(x = x, breaks = 숫자, freq = TRUE, col = "색상명", labels = TRUE,  
       xlim = c(시작점, 끝점), ylim = c(시작점, 끝점),  
       xlab = "X축명", ylab = "Y축명", main = "전체 제목")

```{r}
# 화면을 2행 * 2열로 나눕니다. 
par(mfrow = c(2, 2))

# 히스토그램을 그려봅니다. 
# 먼저 기본형을 그려봅니다. 
hist(x = y, main = "히스토그램 그리기", family = "NanumGothic")

# 빈도수 대신 상대도수를, 회색으로 출력합니다. 
hist(x = y, freq = FALSE, col = "gray50", border = "white", 
     xlab = "데이터", ylab = "상대도수", family = "NanumGothic")

# 막대의 개수를 15개로 늘리고, 상대도수를 함께 출력합니다. 
hist(x = y, labels = TRUE, breaks = 15, 
     freq = FALSE, col = "gray80", ylim = c(0, 0.1))

# 막대의 개수를 15개로 늘리고, 빈도수를 함께 출력합니다. 
hist(x = y, labels = TRUE, breaks = 15, 
     freq = TRUE, col = "blue", ylim = c(0, 20))
```

## 산점도 그리기 (Scatter plot)
> plot(x = x, y = y, type = "p",  
       xlim = c(시작점, 끝점), ylim = c(시작점, 끝점),  
       xlab = "X축명", ylab = "Y축명", main = "전체 제목")

```{r, plot}
# 1~200 값 중 150개씩 임의의 숫자를 갖도록 a, b 객체를 생성합니다. 
a <- sample(x = 1:200, size = 150, replace = FALSE, prob = NULL)
b <- sample(x = 1:200, size = 150, replace = FALSE, prob = NULL)

# a, b 객체로 산점도를 그립니다. 
plot(x = a, y = b, type = "p", 
     xlim = c(0, 200), ylim = c(0, 200), 
     xlab = "X축", ylab = "Y축", 
     main = "산점도 그리기", family = "NanumGothic")
```
