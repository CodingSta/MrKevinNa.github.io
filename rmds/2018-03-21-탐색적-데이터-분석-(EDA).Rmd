---
title: "탐색적 데이터 분석 (EDA)"
author: "Dr.Kevin"
date: "3/27/2018"
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '750px', dpi = 300)
```

일반적으로 데이터 분석 모델링에 앞서 **탐색적 데이터 분석(Explorative Data Analysis)**을 수행합니다. 이 과정에서 분석하려는 데이터의 특성을 다각도로 살펴봄으로써 데이터와 좀 더 친해질 수 있습니다. 아울러 간단한 인사이트도 얻을 수 있습니다.

EDA에는 딱 정해진 과정이 없다고 합니다만, 저는 주로 관심 있는 데이터에 대해 그래프를 그려봄으로써 데이터가 어떤 형태를 띄고 있는지 살펴봅니다. 이번에는 2017년도 프로야구 타자 스탯을 가지고 간단하고 재미있는 EDA를 소개해드리고자 합니다.^[이 내용은 리비전컨설팅 전용준 대표님의 **탐색적분석R**을 사전 승인 받아 재편성한 것임을 알려드립니다.]

## 외부 데이터 읽어오기

먼저 R 외부에 저장되어 있는 `csv`, `txt`, `xlsx` 파일을 읽어오는 방법을 알아보겠습니다. R에서는 이 외에도 `SAS`나 `SPSS` 등 다양한 프로그램 데이터들도 읽어올 수 있으니 관심있는 분들은 따로 찾아보기 바랍니다. 

이번 포스팅에서 사용할 데이터는 지난 [**R Crawler4 JavaScript 우회하기**](https://mrkevinna.github.io/R-Crawler4-JavaScript-%EC%9A%B0%ED%9A%8C%ED%95%98%EA%B8%B0/) 포스팅에서 수집한 `xlsx` 파일입니다. 제가 이 파일을 `csv`와 `txt` 파일로도 변환하여 저의 [GitHub](https://github.com/MrKevinNa/MrKevinNa.github.io/tree/master/rmds/data)에 올렸으니 필요하신 분은 다운로드하기 바랍니다. 

### 외부 데이터 불러오기① : csv 파일

`csv` 파일은 `read.csv()` 함수로 읽습니다. 주요 인자 설정은 다음과 같습니다.

  - `header = TRUE` : 첫 번째 행을 컬럼명으로 인식합니다. 기본 설정이므로 생략해도 됩니다.  
  - `sep = ','` : 데이터 구분자를 콤마(,)로 지정합니다. 기본 설정이므로 생략해도 됩니다.  
  - `stringsAsFactors = FALSE` : TRUE로 하면, 문자열 벡터를 요인(Factor) 타입으로 불러입니다.  
  - `fileEncoding = 'UTF-8'` : UTF-8으로 인코딩된 파일을 불러옵니다. OS에 상관없이 파일 인코딩 방식에 맞춰 불러와야 한글이 깨지지 않습니다.  

그럼 파일의 인코딩 방식을 확인하는 방법을 소개해 드리겠습니다. 
```{r}
# csv 파일이 저장된 경로를 지정합니다. (로컬 컴퓨터에 저장되어 있는 경우도 가능!)
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.csv'

# readr 패키지의 guess_encoding() 함수로 파일의 인코딩 방식을 확인합니다.
readr::guess_encoding(file = filepath)
```

이 함수를 실행하면 대상 파일에서 추정되는 인코딩 방식과 그 확률을 나타냅니다. 일반적으로 확률값이 가장 큰 인코딩 방식으로 정해서 사용하면 됩니다. 실행 결과 `UTF-8`이 `100%`인 것으로 출력되었습니다. 그러므로 Windows 사용자는 반드시 `fileEncoding = 'UTF-8'`을 지정해주어야 하고 Mac 사용자는 기본 인코딩 설정이 `UTF-8`이므로 생략해도 됩니다. 만약 대상 파일의 인코딩 방식이 `EUC-KR`인 경우라면, 이번에는 반대로 Mac 사용자는 반드시 `fileEncoding = 'EUC-KR'`을 지정해주어야 하고 Windows 사용자는 생략해도 됩니다. 인코딩에 대해서 익숙하지 않으면 상당히 혼란을 헷갈리는 부분이니 이번 기회에 꼭 확인하기 바랍니다. 

```{r}
# 불러올 파일이 저장된 경로를 지정합니다. 
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.csv'

# csv 파일을 읽고, dtCsv에 할당합니다. 
dtCsv <- read.csv(file = filepath,
                  stringsAsFactors = FALSE,
                  fileEncoding = "UTF-8")

# 첫 10행만 미리보기 합니다.
head(x = dtCsv, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtCsv)
```

### 외부 데이터 불러오기② : txt 파일

`txt` 파일은 `read.table()` 함수로 읽습니다. `read.csv()` 함수와 주요 인자 설정이 비슷하지만 일부 차이점이 있습니다. 

  - `header = TRUE` : 기본 설정 값이 `FALSE`이므로 첫 번째 행을 컬럼명으로 인식하려면 반드시 지정해주어야 합니다.  
  - `sep = '\t'` : 데이터 구분자를 탭(tab)으로 지정합니다. 기본 설정이므로 생략해도 됩니다.  
  - `stringsAsFactors = FALSE` : `read.csv()`와 같습니다.  
  - `fileEncoding = 'UTF-8'` : `read.csv()`와 같습니다.  

```{r}
# 불러올 파일이 저장된 경로를 지정합니다. 
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.txt'

# txt 파일을 읽고, dtTxt에 할당합니다.
dtTxt <- read.table(file = filepath,
                    header = TRUE,
                    stringsAsFactor = FALSE,
                    fileEncoding = 'UTF-8')

# 첫 10행만 미리보기 합니다.
head(x = dtTxt, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtTxt)
```

### 외부 데이터 불러오기③ : xslx 파일

`csv`는 엑셀에서 열리지만 콤마(,)로 구분된 텍스트 파일이라는 것을 알고 있다면 `txt` 파일과 크게 다를 바가 없습니다. GitHub에서는 이 두 가지 타입의 파일을 `raw` 형태로 브라우져에 렌더링해주고 바로 읽을 수 있게 해줍니다만, `xslx`은 복잡한(?) 엑셀 파일이므로 브라우져에서 확인할 수 없습니다. 따라서 `csv`나 `txt` 파일을 불러온 것처럼 할 수 없으므로, 처음에 알려드린 GitHub Repository에서 다운로드한 후 적당한 폴더에 저장하기 바랍니다. 저는 현재 작업경로에 `data`라는 폴더를 새로 만든 후 그 안에 `xlsx` 파일을 저장하였습니다. 

```{r}
# GitHub Repository에서 xlsx 파일을 다운로드 합니다.
# https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/rmds/data/2017_Baseball_hitter_stat.xlsx

# 현재 작업경로에 데이터를 저장할 폴더(data)가 있는지 확인하고 없으면 새로 만듭니다.
folder <- './data/'
if (dir.exists(paths = folder) == FALSE) dir.create(path = folder)

# 다운로드한 xlsx 파일을 탐색기(또는 파인더)에서 data 폴더로 이동시킨 후
# 해당 파일이 들어있는지 확인합니다. 
list.files(path = folder, pattern = 'xlsx')
```

`xlsx` 파일이 `data` 폴더에 있는 것을 확인했으므로 이제 파일을 읽어옵니다. `xlsx` 파일은 `readxl` 패키지의 `read_excel()` 함수로 읽습니다. 주요 인자는 다음과 같습니다.  

  - `path` : 파일이 저장되어 있는 폴더와 파일명을 지정합니다.  
  - `sheet = NULL` : 데이터가 저장된 sheet가 여러 개일 경우 해당 sheet 이름을 지정합니다.  
  - `col_names = TRUE` : 첫 번째 행을 컬럼명으로 인식합니다. 기본값이 `TRUE`입니다.  

```{r}
# 필요 패키지를 불러옵니다. 
library(readxl)

# xlsx 파일을 읽어, dtXls에 할당합니다. 
dtXls <- read_excel(path = './data/2017_Baseball_hitter_stat.xlsx', sheet = NULL)

# 첫 10행만 미리보기 합니다.
head(x = dtXls, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtXls)
```

지금까지 3가지 방법으로 데이터를 불러온 뒤 저장한 객체들이 서로 같은지 `identical()` 함수를 이용하여 확인해보겠습니다. 

```{r}
# csv 파일을 불러온 객체와 txt 파일을 블러온 객체가 같은지 확인합니다. 
identical(dtCsv, dtTxt)

# csv 파일을 불러온 객체와 xlsx 파일을 블러온 객체가 같은지 확인합니다. 
identical(dtCsv, dtXls)
```

`csv`와 `txt` 파일을 불러온 결과 객체는 서로 같았으나 `xlsx`와는 다르다는 것을 확인할 수 있었습니다. 그 이유는 `read_excel()` 함수는 결과 객체를 데이터프레임(data.frame)이 아닌 티블(tibble)로 반환하기 때문입니다. 티블은 데이터프레임의 일종이지만 데이터프레임이 가지고 있는 여러 가지 단점을 보완한 객체 타입입니다.^[티블에 대한 간략한 설명은 관련 비네트를 참조하시기 바랍니다. RStudio에서 `vignette("tibble")`을 입력한 후 실행하면 `Help` 창에서 관련 내용을 확인할 수 있습니다.]

편의상 `dtXls`를 데이터프레임으로 변환하도록 하겠습니다. 

```{r}
# 데이터프레임으로 변환하기
dtXls <- as.data.frame(x = dtXls)
```

## 프로야구 타자 스탯을 활용한 EDA

이제 `dtXls` 객체를 활용하여 다양한 프로야구 타자 스탯 데이터를 여러 방향을 살펴보겠습니다. 전체 데이터의 구조와 각 열(컬럼)별 형태 및 요약 통계량을 살펴봅니다. 필요한 경우 텍스트 데이터를 수정합니다. 아울러 분석가가 원하는 파생변수도 생성할 수 있으며, 다양한 그래프를 그려봄으로써 분석하려는 데이터가 어떤 내용을 담고 있는지 인사이트를 얻을 수 있습니다. 

### 데이터 구조 파악하기

먼저 데이터의 구조를 파악하는데 필요한 함수 몇 가지를 소개해드립니다.  

  - str() : 객체의 구조를 출력합니다. 데이터프레임의 경우, 컬럼명과 속성 등을 출력합니다.  
  - head() : `n`인자에 숫자를 할당하면, 데이터의 처음 n줄을 출력합니다.
  - tail() : `n`인자에 숫자를 할당하면, 데이터의 마지막 n줄을 출력합니다.  
  - dim() : 객체의 차원을 출력합니다. 데이터프레임의 경우, 행과 열의 수를 각각 출력합니다.  
  - nrow() : 데이터프레임의 행의 수를 출력합니다.  
  - ncol() : 데이터프레임의 열의 수를 출력합니다.  

```{r}
# 데이터프레임의 전체적인 구조(structure)를 확인합니다.
str(object = dtXls)

# 처음 5줄을 확인합니다. 
head(x = dtXls, n = 5L)

# 마지막 5줄을 확인합니다.
tail(x = dtXls, n = 5L)

# 행과 열의 수를 확인합니다. 
dim(x = dtXls)

# 행의 수를 확인합니다. 
nrow(x = dtXls)

# 열의 수를 확인합니다. 
ncol(x = dtXls)
```

이번에는 행 이름과 열 이름을 확인하고 변경하는 방법을 소개하겠습니다. 역시 관련 함수를 먼저 정리해보았습니다.  

  - rownames() : 행 이름을 벡터 형태로 출력합니다. 할당 연산자(`<-`) 우측에 벡터를 지정하면 해당 벡터로 행 이름을 변경할 수 있습니다.  
  - colnames() : 열 이름을 벡터 형태로 출력합니다. 할당 연산자(`<-`) 우측에 벡터를 지정하면 해당 벡터로 열 이름을 변경할 수 있습니다.  
  - dimnames() : 행과 열 이름을 리스트 형태로 출력합니다. 할당 연산자(`<-`) 우측에 행과 열 이름 벡터를 순서대로 리스트 형태로 지정하면 행과 열 이름을 한 번에 변경할 수 있습니다.  

이번 포스팅에서는 행과 열 이름을 각각 확인하는 것만 소개하도록 하겠습니다. 

```{r}
# 행 이름을 확인합니다. 
rownames(x = dtXls)

# 열 이름을 확인합니다. 
colnames(x = dtXls)

# 행과 열 이름을 순서대로 확인합니다.
dimnames(x = dtXls)
```

이제 각 열(컬럼) 벡터의 속성과 기초 통계량을 확인해보겠습니다. 지난 포스팅에서 `summary()` 함수를 소개했는데요. 이 함수를 이용하면 숫자형 벡터는 최소값, 1분위수, 중앙값, 평균, 3분위수, 최대값을 출력해주고, 문자형 벡터는 전체 길이와 속성(Class, Mode)를 출력합니다. 아울러 범주형 벡터는 빈도수 높은 레벨을 내림차순 정렬하여 상위 6개만 출력합니다. 

```{r}
# 불필요한 열(순위)을 삭제합니다.
dtXls <- dtXls[, -1]

# 팀명을 범주형 벡터로 변환합니다. 
dtXls$팀명 <- as.factor(dtXls$팀명)

# 각 열별 요약 통계량을 출력합니다. 
summary(object = dtXls)
```

**선수명**은 문자형 벡터라 전체 길이(292)와 `Class` 및 `Mode`를 출력하였습니다. **팀명**은 범주형 벡터라 빈도수가 높은 팀을 내림차순하여 상위 6개 팀만 출력하였습니다. 나머지 열은 모두 숫자형 벡터라 6가지 요약 통계량을 각각 출력하였습니다. 

### 텍스트 처리하기^[데이터 전처리를 하다보면 텍스트 데이터를 자유자재로 다루어야 하는 경우가 많습니다. 이와 관련된 내용은 별도의 포스팅에 정리하였으니 관심 있는 분들은 [stringr 패키지 주요 함수 소개](https://mrkevinna.github.io/stringr-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%A3%BC%EC%9A%94-%ED%95%A8%EC%88%98-%EC%86%8C%EA%B0%9C/)를 참조하시기 바랍니다.]

선수명에 공백이 있는지 확인하고, 공백이 있으면 제거하겠습니다. 

```{r}
# 선수명에 공백이 있는지 확인합니다. 
dtXls$선수명 %>% str_subset(pattern = ' ')
```

선수명에 공백이 없음을 확인하였습니다. 만약 선수명에 공백이 있었다면 아래 코드로 공백을 제거할 수 있습니다. 

```{r}
# 선수명에 공백을 제거합니다.
dtXls$선수명 <- dtXls$선수명 %>%
  str_replace_all(pattern = ' ', replacement = '')
```

### 새로운 열(컬럼) 추가하기

이번에는 특정 팀의 선수들 명단을 확인해보도록 하겠습니다. 자신이 응원하는 팀으로 지정해보시기 바랍니다. 

```{r}
# 특정 팀에 속한 선수명을 출력합니다.
dtXls[dtXls$팀명 == 'KIA', '선수명']
```

이 중에서 관심 있는 선수들만 골라서 `관심선수`라는 새로운 열(컬럼)을 생성합니다. 

```{r}
# 관심선수 명단을 벡터에 할당합니다. 
관심선수 <- c('이명기', '김주찬', '버나디나', '최형우', '나지완', '안치홍', '이범호', '김민식', '김선빈')

# 전체 데이터에서 관심선수이 경우 '1', 아니면 '0'을 가지는 새로운 열(컬럼)을 생성합니다. 
dtXls$관심선수 <- ifelse(test = dtXls$선수명 %in% 관심선수, yes = '1', no = '0')

# 관심선수의 스탯만 출력합니다. 
dtXls[dtXls$관심선수 == '1', ]
```

### 산점도 그려보기 

어느 정도 데이터 전처리가 마무리 되었으니 이제 그래프를 그려보겠습니다. 우선 산점도를 그려볼텐데요. 분석 대상인 데이터의 컬럼이 `p`개인 `p`차원 데이터에서 2개를 선별하여 2차원 평면에 그려봄으로써 데이터가 어떻게 분포하는지 확인할 수 있습니다. 

```{r}
# 타수와 타율을 기준으로 산점도를 그려봅니다. 
plot(x = dtXls$타수,
     y = dtXls$타율,
     main = '타수와 타율 간 관계',
     xlab = '타수',
     ylab = '타율',
     family = "NanumGothic")
```

타수가 적은 선수들 중 일부가 높은 타율을 보이므로 분석 대상에서 제외하는 것이 좋습니다. 타수로 도수분포표를 만든 후 일부 데이터를 삭제하도록 하겠습니다. 

```{r}
# 타수의 빈도를 확인합니다.
table(dtXls$타수)

# 타수 빈도의 최소값과 최대값을 확인합니다. 
range(dtXls$타수)

# 타수의 계급폭을 50으로 지정합니다. 
breaks <- seq(from = min(dtXls$타수), 
              to = max(dtXls$타수),
              by = 50)

# 계급을 확인합니다. 
cat("breaks :", breaks, "\n")

# 도수분포표를 만들고 확인합니다. 
cut4ab1 <- cut(x = dtXls$타수, breaks = breaks, include.lowest = TRUE, right = FALSE)
table(cut4ab1)
```

`cut()` 함수를 사용하여 도수분포표를 만들 때, 이번 예제의 경우 `550`을 초과하는 데이터를 포함하지 않는 단점이 있습니다. `seq()` 함수를 이용하여 `breaks`를 만들 때 최대값을 넘는 값을 만들지 못하기 때문입니다. 이를 보완하려면 **Hmics** 패키지의 `cut2()` 함수를 이용하면 됩니다. 

```{r}
# cut2() 함수를 사용하여 550을 초과하는 데이터도 포함시킵니다. 
cut4ab2 <- Hmisc::cut2(x = dtXls$타수, cuts = breaks, minmax = TRUE)
table(cut4ab2)

# prop.table() 함수를 이용하여 상대도수를 확인합니다. 
table(cut4ab2) %>% prop.table() %>% round(digits = 2L)

# cumsum() 함수를 추가하여 누적상대도수를 확인합니다.
table(cut4ab2) %>% prop.table() %>% round(digits = 2L) %>% cumsum()
```

50타수 미만인 타자가 117명으로 전체 타자 중에서 약 40%의 비중을 차지하는 것을 알 수 있습니다. 산점도에서도 50타수 이하는 타율의 변동폭이 매우 크므로 50타수 이상인 타자들만 따로 선별하여 추가 분석을 진행하도록 하겠습니다. 

```{r}
# 50 타수 이상인 타자만 추출하여 dtXls50 객체에 할당합니다. 
dtXls50 <- dtXls[dtXls$타수 >= 50, ]

# 새로운 데이터프레임의 차원을 확인합니다. 
dim(x = dtXls50)
```

전체 행(선수)가 175명으로 줄어들었습니다. 이제 이 데이터로 다시 산점도를 그려보겠습니다. 그리고 타수와 타율 간 선형관계를 확인하고자 단순선형회귀선을 추가하겠습니다.

```{r}
# 타수와 타율을 기준으로 산점도를 그려봅니다. 
plot(x = dtXls50$타수,
     y = dtXls50$타율,
     main = '타수와 타율 간 관계 (50타수 이상 타자)',
     xlab = '타수',
     ylab = '타율',
     family = "NanumGothic")

# 타수와 타율 간 선형관계를 확인하고자 단순선형회귀선을 추가합니다.
abline(reg = lm(formula = 타율 ~ 타수, data = dtXls50),
       col = "red",
       lty = 2)
```

빨간색 회귀선 위, 아래로 점들이 고르게 퍼져 있는 것을 알 수 있습니다. 나중에 선형회귀를 다룰 때 자세하게 정리할 예정이지만, 독립변수가 1개인 선형회귀식의 **결정계수(R-squared)**는 두 변수 간 상관계수의 제곱으로 간단하게 구할 수 있습니다. 

```{r}
# 두 변수 간 상관계수를 구합니다. 
cor.test(x = dtXls50$타수, y = dtXls50$타율)

# 상관계수의 제곱을 출력합니다. 
cor(x = dtXls50$타수, y = dtXls50$타율) %>% .^2
```

두 변수 간 피어슨 상관계수를 계산해보니 약 0.614이며, 이 때 p-value는 0이라 할 수 있으므로 두 변수 간 강한 양의 상관관계가 있다고 추정할 수 있습니다. 상관계수를 제곱하면 이 선형회귀식의 결정계수는 약 0.377이 됩니다. 

위와 같이 두 변수를 할당하면 산점도를 그리고 상관계수와 상관계수의 제곱을 출력하는 사용자 정의 함수를 생성해보겠습니다. 

```{r}
# 사용자 정의 함수: 두 데이터 간 상관계수를 구하고, 산점도를 그려봅니다.
checkCorPlot <- function(var1, var2) {
  
  # var1과 var2를 문자열로 변환하여 각각의 이름에 할당합니다.
  var1name <- substitute(expr = var1) %>% deparse() %>% str_split(pattern = '\\$') %>% `[[`(1) %>% `[`(2)
  var2name <- substitute(expr = var2) %>% deparse() %>% str_split(pattern = '\\$') %>% `[[`(1) %>% `[`(2)
  
  # 산점도를 그립니다. 
  plot(x = var1,
       y = var2,
       main = paste0(var1name, ' & ', var2name, ' 간 관계'),
       xlab = var1name, 
       ylab = var2name,
       family = "NanumGothic")
  
  # 상관계수를 계산합니다. 
  # cor.test()를 실행하면, 결과 객체로 리스트를 반환합니다. 
  # 상관계수는 estimate 원소로 저장되므로 `$` 함수를 사용하여 추출합니다. 
  cor <- cor.test(x = var1, y = var2) %>% `$`(estimate) %>% round(digits = 3L) 
  rsq <- cor %>% .^2 %>% round(digits = 3L) 
  
  # 산점도에서 상관계수를 출력할 위치를 잡습니다. 
  locX <- max(var1, na.rm = TRUE) * 0.9
  locY <- max(var2, na.rm = TRUE) * 0.4
  
  # 한글이 제대로 보이도록 한글폰트를 지정합니다.
  par(family = 'NanumGothic')
  
  # 산점도 우측 하단에 상관계수를 출력합니다.
  text(x = locX,
       y = locY,
       labels = str_c('상관계수 : ', cor %>% str_pad(width = 5, side = 'right', pad = '0')),
       font = 2)
  
  # 산점도에 선형회귀선을 추가합니다. 
  reg <- lm(formula = var2 ~ var1)
  abline(reg = reg, col = "red", lty = 2)
}

# 화면을 2행 * 2열로 분할합니다. 
par(mfrow = c(2, 2))

# 입력변수를 바꿔가면서 산점도를 그려봅니다. 
checkCorPlot(var1 = dtXls50$홈런, var2 = dtXls50$타율)
checkCorPlot(var1 = dtXls50$삼진, var2 = dtXls50$타율)
checkCorPlot(var1 = dtXls50$타점, var2 = dtXls50$타율)
checkCorPlot(var1 = dtXls50$득점, var2 = dtXls50$타율)

# 분할된 화면을 원래대로 (1행 * 1열) 되돌려 놓습니다. 
par(mfrow = c(2, 2))
```

위와 같은 방법으로는 분석가가 하나씩 지정해주기 전까지 한꺼번에 두 변수 간 관계를 알아보기 어렵습니다. 이런 문제는 `pairs()` 함수를 사용하여 쉽게 해결할 수 있습니다. 이 함수에 데이터프레임을 할당하면 모든 숫자형 벡터들을 2개씩 골라 산점도를 그려줍니다. 

```{r}
# 여러 숫자형 벡터 간 산점도를 한꺼번에 출력합니다. 
pairs(x = dtXls50[, c(6:12, 14)])
```

두 숫자형 벡터 간 공분산과 상관계수 행렬를 구하면 관계의 정도를 숫자로 확인할 수 있습니다. 공분산은 두 개의 변수가 변화하는 정도는 알 수 있으나 서로 비교하기 어려우므로, 공분산을 각각의 표준편차로 나누어 표준화한 상관계수 행렬을 구하면 상관관계의 정도를 서로 비교할 수 있습니다. 

```{r}
# 공분산 행렬을 출력합니다. 
cov(x = dtXls50[, c(6:12, 14)])

# 상관계수 행렬을 출력합니다. 
cor(x = dtXls50[, c(6:12, 14)])
```

`pairs()` 함수의 패널을 분석가가 임의로 정할 수 있습니다. 대각원소의 오른쪽 위를 상삼각행렬이라고 하고, 왼쪽 아래를 하삼각행렬이라고 하는데, 이번 예제에서는 상삼각행렬을 산점도 대신 상관계수와 p-value를 출력하도록 변경해보겠습니다.^[보다 상세한 내용은 [관련 블로그](http://r-nold.blogspot.kr/2014/11/scatter-plot-matrices-in-r.html)를 참조하시기 바랍니다.]

```{r}
# 삼각행렬의 패널에 분석가가 원하는 출력 방식을 지정합니다. 
panel.cor <- function(x, y, digits = 2, cex.cor, ...) {
    
    # 그래프를 출력할 범위를 지정합니다. 
    usr <- par("usr")
    on.exit(expr = par(usr))
    par(usr = c(0, 1, 0, 1))
    
    # 상관계수를 계산합니다. 
    r <- cor(x = x, y = y)
    txt1 <- format(x = c(r, 0.123456789), digits = digits)[1]
    txt1 <- paste("r : ", txt1, sep = "")
    text(x = 0.5, y = 0.6, labels = txt1, cex = 1.0)
    
    # p-value를 계산합니다. 
    p <- cor.test(x = x, y = y)$p.value
    txt2 <- format(x = c(p, 0.123456789), digits = digits)[1]
    txt2 <- paste("p : ", txt2, sep = "")
    if(p < 0.01) txt2 <- paste("p : ", "< 0.01", sep = "")
    text(x = 0.5, y = 0.4, labels = txt2, cex = 1.0)
}

# 위에서 생성한 사용자 정의 함수를 활용하여 산점도 행렬을 그려봅니다. 
pairs(x = dtXls50[, c(6:12, 14)], upper.panel = panel.cor)
```

### 파생변수 만들기

