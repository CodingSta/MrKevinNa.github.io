---
title: "탐색적 데이터 분석 (EDA)"
author: "Dr.Kevin"
date: "3/27/2018"
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '750px', dpi = 300)
```

일반적으로 데이터 분석 모델링에 앞서 **탐색적 데이터 분석(Explorative Data Analysis)**을 수행합니다. 이 과정에서 분석하려는 데이터의 특성을 다각도로 살펴봄으로써 데이터와 좀 더 친해질 수 있습니다. 아울러 간단한 인사이트도 얻을 수 있습니다.

EDA에는 딱 정해진 과정이 없다고 합니다만, 저는 주로 관심 있는 데이터에 대해 그래프를 그려봄으로써 데이터가 어떤 형태를 띄고 있는지 살펴봅니다. 이번에는 2017년도 프로야구 타자 스탯을 가지고 간단하고 재미있는 EDA를 소개해드리고자 합니다.^[이 내용은 리비전컨설팅 전용준 대표님의 **탐색적분석R**을 사전 승인 받아 재편성한 것임을 알려드립니다.]

## 외부 데이터 읽어오기

먼저 R 외부에 저장되어 있는 `csv`, `txt`, `xlsx` 파일을 읽어오는 방법을 알아보겠습니다. R에서는 이 외에도 `SAS`나 `SPSS` 등 다양한 프로그램 데이터들도 읽어올 수 있으니 관심있는 분들은 따로 찾아보기 바랍니다. 

이번 포스팅에서 사용할 데이터는 지난 [**R Crawler4 JavaScript 우회하기**](https://mrkevinna.github.io/R-Crawler4-JavaScript-%EC%9A%B0%ED%9A%8C%ED%95%98%EA%B8%B0/) 포스팅에서 수집한 `xlsx` 파일입니다. 제가 이 파일을 `csv`와 `txt` 파일로도 변환하여 저의 [GitHub](https://github.com/MrKevinNa/MrKevinNa.github.io/tree/master/rmds/data)에 올렸으니 필요하신 분은 다운로드하기 바랍니다. 

### 외부 데이터 불러오기① : csv 파일

`csv` 파일은 `read.csv()` 함수로 읽습니다. 주요 인자 설정은 다음과 같습니다.

  - `header = TRUE` : 첫 번째 행을 컬럼명으로 인식합니다. 기본 설정이므로 생략해도 됩니다.  
  - `sep = ','` : 데이터 구분자를 콤마(,)로 지정합니다. 기본 설정이므로 생략해도 됩니다.  
  - `stringsAsFactors = FALSE` : TRUE로 하면, 문자열 벡터를 요인(Factor) 타입으로 불러입니다.  
  - `fileEncoding = 'UTF-8'` : UTF-8으로 인코딩된 파일을 불러옵니다. OS에 상관없이 파일 인코딩 방식에 맞춰 불러와야 한글이 깨지지 않습니다.  

그럼 파일의 인코딩 방식을 확인하는 방법을 소개해 드리겠습니다. 
```{r}
# csv 파일이 저장된 경로를 지정합니다. (로컬 컴퓨터에 저장되어 있는 경우도 가능!)
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.csv'

# readr 패키지의 guess_encoding() 함수로 파일의 인코딩 방식을 확인합니다.
readr::guess_encoding(file = filepath)
```

이 함수를 실행하면 대상 파일에서 추정되는 인코딩 방식과 그 확률을 나타냅니다. 일반적으로 확률값이 가장 큰 인코딩 방식으로 정해서 사용하면 됩니다. 실행 결과 `UTF-8`이 `100%`인 것으로 출력되었습니다. 그러므로 Windows 사용자는 반드시 `fileEncoding = 'UTF-8'`을 지정해주어야 하고 Mac 사용자는 기본 인코딩 설정이 `UTF-8`이므로 생략해도 됩니다. 만약 대상 파일의 인코딩 방식이 `EUC-KR`인 경우라면, 이번에는 반대로 Mac 사용자는 반드시 `fileEncoding = 'EUC-KR'`을 지정해주어야 하고 Windows 사용자는 생략해도 됩니다. 인코딩에 대해서 익숙하지 않으면 상당히 혼란을 헷갈리는 부분이니 이번 기회에 꼭 확인하기 바랍니다. 

```{r}
# 불러올 파일이 저장된 경로를 지정합니다. 
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.csv'

# csv 파일을 읽고, dtCsv에 할당합니다. 
dtCsv <- read.csv(file = filepath,
                  stringsAsFactors = FALSE,
                  fileEncoding = "UTF-8")

# 첫 10행만 미리보기 합니다.
head(x = dtCsv, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtCsv)
```

### 외부 데이터 불러오기② : txt 파일

`txt` 파일은 `read.table()` 함수로 읽습니다. `read.csv()` 함수와 주요 인자 설정이 비슷하지만 일부 차이점이 있습니다. 

  - `header = TRUE` : 기본 설정 값이 `FALSE`이므로 첫 번째 행을 컬럼명으로 인식하려면 반드시 지정해주어야 합니다.  
  - `sep = '\t'` : 데이터 구분자를 탭(tab)으로 지정합니다. 기본 설정이므로 생략해도 됩니다.  
  - `stringsAsFactors = FALSE` : `read.csv()`와 같습니다.  
  - `fileEncoding = 'UTF-8'` : `read.csv()`와 같습니다.  

```{r}
# 불러올 파일이 저장된 경로를 지정합니다. 
filepath <- 'https://raw.githubusercontent.com/MrKevinNa/MrKevinNa.github.io/master/rmds/data/2017_Baseball_hitter_stat.txt'

# txt 파일을 읽고, dtTxt에 할당합니다.
dtTxt <- read.table(file = filepath,
                    header = TRUE,
                    stringsAsFactor = FALSE,
                    fileEncoding = 'UTF-8')

# 첫 10행만 미리보기 합니다.
head(x = dtTxt, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtTxt)
```

### 외부 데이터 불러오기③ : xslx 파일

`csv`는 엑셀에서 열리지만 콤마(,)로 구분된 텍스트 파일이라는 것을 알고 있다면 `txt` 파일과 크게 다를 바가 없습니다. GitHub에서는 이 두 가지 타입의 파일을 `raw` 형태로 브라우져에 렌더링해주고 바로 읽을 수 있게 해줍니다만, `xslx`은 복잡한(?) 엑셀 파일이므로 브라우져에서 확인할 수 없습니다. 따라서 `csv`나 `txt` 파일을 불러온 것처럼 할 수 없으므로, 처음에 알려드린 GitHub Repository에서 다운로드한 후 적당한 폴더에 저장하기 바랍니다. 저는 현재 작업경로에 `data`라는 폴더를 새로 만든 후 그 안에 `xlsx` 파일을 저장하였습니다. 

```{r}
# GitHub Repository에서 xlsx 파일을 다운로드 합니다.
# https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/rmds/data/2017_Baseball_hitter_stat.xlsx

# 현재 작업경로에 데이터를 저장할 폴더(data)가 있는지 확인하고 없으면 새로 만듭니다.
folder <- './data/'
if (dir.exists(paths = folder) == FALSE) dir.create(path = folder)

# 다운로드한 xlsx 파일을 탐색기(또는 파인더)에서 data 폴더로 이동시킨 후
# 해당 파일이 들어있는지 확인합니다. 
list.files(path = folder, pattern = 'xlsx')
```

`xlsx` 파일이 `data` 폴더에 있는 것을 확인했으므로 이제 파일을 읽어옵니다. `xlsx` 파일은 `readxl` 패키지의 `read_excel()` 함수로 읽습니다. 주요 인자는 다음과 같습니다.  

  - `path` : 파일이 저장되어 있는 폴더와 파일명을 지정합니다.  
  - `sheet = NULL` : 데이터가 저장된 sheet가 여러 개일 경우 해당 sheet 이름을 지정합니다.  
  - `col_names = TRUE` : 첫 번째 행을 컬럼명으로 인식합니다. 기본값이 `TRUE`입니다.  

```{r}
# 필요 패키지를 불러옵니다. 
library(readxl)

# xlsx 파일을 읽어, dtXls에 할당합니다. 
dtXls <- read_excel(path = './data/2017_Baseball_hitter_stat.xlsx', sheet = NULL)

# 첫 10행만 미리보기 합니다.
head(x = dtXls, n = 10L)

# 데이터의 구조를 파악합니다.
str(object = dtXls)
```

지금까지 3가지 방법으로 데이터를 불러온 뒤 저장한 객체들이 서로 같은지 `identical()` 함수를 이용하여 확인해보겠습니다. 

```{r}
# csv 파일을 불러온 객체와 txt 파일을 블러온 객체가 같은지 확인합니다. 
identical(dtCsv, dtTxt)

# csv 파일을 불러온 객체와 xlsx 파일을 블러온 객체가 같은지 확인합니다. 
identical(dtCsv, dtXls)
```

`csv`와 `txt` 파일을 불러온 결과 객체는 서로 같았으나 `xlsx`와는 다르다는 것을 확인할 수 있었습니다. 그 이유는 `read_excel()` 함수는 결과 객체를 데이터프레임(data.frame)이 아닌 티블(tibble)로 반환하기 때문입니다. 티블은 데이터프레임의 일종이지만 데이터프레임이 가지고 있는 여러 가지 단점을 보완한 객체 타입입니다.^[티블에 대한 간략한 설명은 관련 비네트를 참조하시기 바랍니다. RStudio에서 `vignette("tibble")`을 입력한 후 실행하면 `Help` 창에서 관련 내용을 확인할 수 있습니다.]

## 프로야구 타자 스탯을 활용한 EDA

이제 `dtXls` 객체를 활용하여 다양한 프로야구 타자 스탯 데이터를 여러 방향을 살펴보겠습니다. 전체 데이터의 구조와 각 열(컬럼)별 형태 및 요약 통계량을 살펴봅니다. 필요한 경우 텍스트 데이터를 수정합니다. 아울러 분석가가 원하는 파생변수도 생성할 수 있으며, 다양한 그래프를 그려봄으로써 분석하려는 데이터가 어떤 내용을 담고 있는지 인사이트를 얻을 수 있습니다. 

### 데이터 구조 파악하기

먼저 데이터의 구조를 파악하는데 필요한 함수 몇 가지를 소개해드립니다.  

  - str() : 객체의 구조를 출력합니다. 데이터프레임의 경우, 컬럼명과 속성 등을 출력합니다.  
  - head() : `n`인자에 숫자를 할당하면, 데이터의 처음 n줄을 출력합니다.
  - tail() : `n`인자에 숫자를 할당하면, 데이터의 마지막 n줄을 출력합니다.  
  - dim() : 객체의 차원을 출력합니다. 데이터프레임의 경우, 행과 열의 수를 각각 출력합니다.  
  - nrow() : 데이터프레임의 행의 수를 출력합니다.  
  - ncol() : 데이터프레임의 열의 수를 출력합니다.  

```{r}
# 데이터프레임의 전체적인 구조(structure)를 확인합니다.
str(object = dtXls)

# 처음 5줄을 확인합니다. 
head(x = dtXls, n = 5L)

# 마지막 5줄을 확인합니다.
tail(x = dtXls, n = 5L)

# 행과 열의 수를 확인합니다. 
dim(x = dtXls)

# 행의 수를 확인합니다. 
nrow(x = dtXls)

# 열의 수를 확인합니다. 
ncol(x = dtXls)
```

이번에는 행 이름과 열 이름을 확인하고 변경하는 방법을 소개하겠습니다. 역시 관련 함수를 먼저 정리해보았습니다.  

  - rownames() : 행 이름을 벡터 형태로 출력합니다. 할당 연산자(`<-`) 우측에 벡터를 지정하면 해당 벡터로 행 이름을 변경할 수 있습니다.  
  - colnames() : 열 이름을 벡터 형태로 출력합니다. 할당 연산자(`<-`) 우측에 벡터를 지정하면 해당 벡터로 열 이름을 변경할 수 있습니다.  
  - dimnames() : 행과 열 이름을 리스트 형태로 출력합니다. 할당 연산자(`<-`) 우측에 행과 열 이름 벡터를 순서대로 리스트 형태로 지정하면 행과 열 이름을 한 번에 변경할 수 있습니다.  

이번 포스팅에서는 행과 열 이름을 각각 확인하는 것만 소개하도록 하겠습니다. 

```{r}
# 행 이름을 확인합니다. 
rownames(x = dtXls)

# 열 이름을 확인합니다. 
colnames(x = dtXls)

# 행과 열 이름을 순서대로 확인합니다.
dimnames(x = dtXls)
```

이제 각 열(컬럼) 벡터의 속성과 기초 통계량을 확인해보겠습니다. 지난 포스팅에서 `summary()` 함수를 소개했는데요. 이 함수를 이용하면 숫자형 벡터는 최소값, 1분위수, 중앙값, 평균, 3분위수, 최대값을 출력해주고, 문자형 벡터는 전체 길이와 속성(Class, Mode)를 출력합니다. 아울러 범주형 벡터는 빈도수 높은 레벨을 내림차순 정렬하여 상위 6개만 출력합니다. 

```{r}
# 불필요한 열(순위)을 삭제합니다.
dtXls <- dtXls[, -1]

# 팀명을 범주형 벡터로 변환합니다. 
dtXls$팀명 <- as.factor(dtXls$팀명)

# 각 열별 요약 통계량을 출력합니다. 
summary(object = dtXls)
```

**선수명**은 문자형 벡터라 전체 길이(292)와 `Class` 및 `Mode`를 출력하였습니다. **팀명**은 범주형 벡터라 빈도수가 높은 팀을 내림차순하여 상위 6개 팀만 출력하였습니다. 나머지 열은 모두 숫자형 벡터라 6가지 요약 통계량을 각각 출력하였습니다. 

