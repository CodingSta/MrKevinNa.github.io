Open API란?
-----------

**API**는 Application Programming Interface의 머릿글자로 응용프로그램 프로그래밍 인터페이스라고 할 수 있는데요. 저도 전문적인 것은 모릅니다. 다만 제가 사용하는 방식으로 설명을 대신하면 다음과 같습니다.

**사용자**인 제가 **API 서비스 제공자**인 공공데이터 포털에게 원하는 데이터를 **요청(Request)**하고 **응답(Response)**받는 방식으로 해당 데이터를 **XML** 또는 **JSON** 형태로 제공받는 것입니다. 그리고 Open API는 서비스를 신청하는 모든 사람에게 열려있다는 의미입니다. 사용자가 어떤 데이터에 대해 **활용신청**을 하면 API 서비스 제공자는 **인증키**를 발급해주어야 하고, 나중에 사용자가 해당 서비스를 요청하려면 발급받은 인증키를 요청 URL에 포함시켜야 하는 거죠.

Open API가 무료로 제공된다고 해도 **일별 호출수**를 제한하는 경우가 일반적이고, 일별 호출수 한도를 초과하여 사용하려는 사용자에게 과금하는 경우도 있습니다. 우리나라 정부는 [공공데이터 포털](https://www.data.go.kr)을 통해 정부기관에서 보유하고 있는 공공데이터를 무료로 공개하고 있습니다. 물론 일별 호출수 한도가 있구요.

사실 공공데이터 포털에서 데이터를 제공하는 형태는 크게 2가지로, 파일데이터와 Open API가 있습니다. 파일데이터는 우리에게 아주 익숙한 형태(예컨데, xlsx 또는 csv 파일)로 다운로드 받을 수 있게 한 것입니다. 하지만 Open API를 이용하면 파일을 다운로드하고 다시 R에서 불러오는 등의 불필요한 작업을 최소화 할 수 있습니다.

이미 언급한 바와 같이 공공데이터 Open API를 사용하려면 미리 활용신청을 해야 합니다. 이번 포스트에서는 **조달청 나라장터 낙찰정보**를 Open API 인증키를 받고 원하는 데이터를 수집하는 방법에 대해서 소개하겠습니다.

### 공공데이터 포털 인증키 발급받기

인증키 발급방법을 아래와 같이 몇 장의 화면 캡쳐 이미지로 설명을 하겠습니다. 먼저 공공데이터 포털에 접속하여 회원가입을 하고 로그인까지 합니다.

1.  공공데이터 포털 메인화면 상단 검색창에 **나라장터**를 입력합니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/공공데이터포털_메인화면.png?raw=true)

1.  검색 결과에서 검색창 바로 아래 전체, 파일데이터, 오픈API, 표준데이터 메뉴가 보일 것입니다. 이 중에서 **오픈API**를 선택하고 아래 목록에서 **조달청\_낙찰정보**를 클릭합니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_OpenAPI_리스트.png?raw=true)

1.  조달청\_낙찰정보 상세화면이 열리면 아래 그림에서 보이는 것처럼 **활용신청**을 클릭합니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_API.png?raw=true)

1.  개발계정 신청화면으로 이동하면, 나머지 항목은 그대로 둔 채 화면 아래쪽에 있는 **상세기능정보**로 이동하여 상세기능 중 필요한 항목을 선택합니다. 모두 선택해도 됩니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_API_Key_신청1.png?raw=true)

1.  상세기능을 다 선택했다면 **라이센스표시**에서 **동의합니다**를 선택한 후, **신청**버튼을 클릭합니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_API_Key_신청2.png?raw=true)

1.  위 과정을 모두 거치면 아래 이미지와 같이 개발계정 신청이 완료됩니다. 웹페이지 가운데에 확인창을 클릭하면 **마이페이지 &gt; 개발계정** 화면으로 이동하여 (이미 승인받은 다른 항목이 있다면) 승인받은 목록을 한 번에 확인할 수 있습니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_API_Key_신청3.png?raw=true)

1.  **마이페이지 &gt; 개발계정**에서 방금 신청한 **나라장터 낙찰정보서비스**를 클릭하면 **개발계정 상세보기** 화면으로 이동하는데, 여기에서 **인증키**를 확인할 수 있습니다. 나중에 데이터를 요청할 때 사용해야 하므로 복사한 다음 R에서 적당한 객체명을 붙여 할당해놓습니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_API_Key_확인.png?raw=true)

한 가지 중요한 것은, 위 이미지에서 **참고문서**를 잘 읽어봐야 한다는 것입니다. 일단은 적당한 폴더에 저장합니다. 나중에 따로 설명하도록 하겠습니다.

이상으로 공공데이터 포털 Open API 신청하는 것을 소개했습니다. 다른 데이터 항목들에 대해서는 인증키 신청방법이 같으니 필요한 항목은 미리미리 신청하시기 바랍니다.

### 조달청 나라장터 낙찰리스트 수집하기

바로 위에서 언급한 참고문서인 **조달청\_OpenAPI활용가이드\_나라장터\_낙찰정보서비스\_1.1.docx**를 엽니다. 4페이지 아래 표를 보면, **나라장터 낙찰 정보서비스**에서 물품, 공사, 용역, 외자 등의 항목에 대해 조회할 수 있다는 것을 알 수 있습니다. 이 표에 있는 **오퍼레이션**은 서비스 요청할 때 사용됩니다.

6~12페이지에 걸쳐 **낙찰된 목록 현황 물품조회**에 대한 오퍼레이션 명세를 확인할 수 있습니다. 간단하게 설명하자면 **요청 메시지 명세** 테이블에 있는 항목을 조합하여 서비스 요청을 하면 정상적으로 응답을 받게 될 경우 **응답 메시지 명세** 테이블에 있는 항목을 받을 수 있다는 것입니다. 응답 데이터 형태는 **XML**이며, 그냥 HTML처럼 처리하면 됩니다. 하지만 **rvest** 패키지의 `read_xml()`과 `xml_nodes()` 등을 이용해서 처리한다는 점에서 다릅니다. 만약 `read_html()`을 사용하면 tag의 대문자가 모두 소문자로 바뀌게 됩니다.

예시를 보면 더욱 쉽게 이해할 수 있습니다. 11페이지 **요청 / 응답 메시지 예제**를 보시기 바랍니다. 웹크롤링을 할 때 `GET()` 인자로 url을 넣어서 요청을 하는데, Open API도 URL을 조합하여 요청하면 됩니다. URL의 요소로는 앞에서 언급한 **요청 메시지 명세**를 참고하면 되구요. 요청이 정상적으로 처리되면 **응답 메시지 명세**에서 보이는 형태의 데이터를 받을 수 있습니다. 이 XML을 우리가 알고 있는 **rvest** 함수들로 정리해주면 끝입니다.

백문이 불여일견이고, 백견이 불여일각이며, 백각이 불여일행[1]이니, 지금부터 Open API 방식으로 공공데이터를 수집하는 코드를 소개하겠습니다. 먼저 요청 URL의 공동부분(main)과 조회항목(이 예제에서는 '물품')을 설정하고 인증키는 `key`에 할당합니다. 그리고 요청 메시지 명세에 있는 나머지 항목들을 순서대로 정리하여 URL을 조립해보겠습니다.

``` r
# 공통부분
main <- "http://apis.data.go.kr/1230000/ScsbidInfoService/"

# "물품" 지정
item <- "getScsbidListSttusThng"
```

``` r
# 인증키 (ServiceKey)
key <- "여기에 인증키를 복사해서 붙여넣습니다"
```

``` r
# 한 페이지 결과 수 (numOfRows)
rows <- 2

# 페이지 번호 (pageNo)
page <- 1

# 조회구분 (inqryDiv)
inqry <- 1

# 조회시작일시 (inqryBgnDt)
bgnDate <- 20180101

# 조회종료일시 (inqryEndDt)
endDate <- 20180131
```

``` r
# url 조립
# 각각의 요소를 묶을 때 사용되는 구분자(?, &)를 주의깊게 확인할 것!
url <- paste0(main,
              item,
              paste0("?ServiceKey=", key),
              paste0("&numOfRows=", rows),
              paste0("&pageNo=", page),
              paste0("&inqryDiv=", inqry),
              paste0("&inqryBgnDt=", bgnDate),
              paste0("&inqryEndDt=", endDate)
              )

# 조립한 url 출력
cat(url)
```

각자의 인증키를 넣은 url을 조립했으면 출력된 결과를 복사해서 웹브라우저 주소창에 붙여넣기 해보겠습니다. 그러면 아래와 같은 이미지가 보일 것입니다. 이 형태가 **XML**입니다. XML은 HTML과 비슷해보이지만 사용자 입장에서는 필요한 데이터만 군더더기 없이 깔끔하게 제공되기 때문에 HTML보다 다루기 쉽다는 장점이 있습니다.

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Open_API/조달청_나라장터_낙찰정보_XML_예시.png?raw=true)

위 이미지의 맨 아래를 보면 전체 건수가 4,513건임을 알 수 있습니다. 그리고 현재 2건의 데이터가 화면에 보이며, 그 2건은 `<item>` 태그로 묶여서 각각 18개의 세부 항목이 제공되고 있습니다.

그럼 이 url로 요청하고 응답받은 XML을 정리하는 방법에 대해 알려드리겠습니다. 간단하게 `GET()`를 이용하여 요청하면 됩니다.

``` r
# 필요 패키지 불러오기
library(httr)
library(rvest)
library(dplyr)
library(stringr)
library(magrittr)
```

``` r
# url로 요청하기
resp <- GET(url)

# 응답 상태코드 확인
status_code(resp)
```

    ## [1] 200

응답 상태코드가 정상(200)입니다. 이제 `<item>` 단위로 데이터를 정리하면 됩니다.

``` r
# 낙찰리스트 정리하기
# 낙찰리스트는 body > items > item의 하위 태그로 제공되고 있음
# 예를 들어, 입찰공고번호(bidntceno)만 추출!
read_xml(resp) %>% 
  xml_nodes("item") %>% 
  xml_node("bidntceno") %>% 
  xml_text()
```

    ## [1] NA NA

위에서 보면 알 수 있듯이 18개 항목 중 필요한 부분만 수집할 수 있습니다. 이 과정을 좀 더 간단하게 하기 위해 위 코드에서 첫 두 줄을 실행하여 `items`에 할당하기로 합니다. 그리고 아래 두 줄을 사용자 정의 함수로 만들면 코드를 보다 간결하게 만들 수 있습니다.

``` r
# 반복되는 부분을 items 객체에 할당
items <- read_xml(resp) %>% xml_nodes("item")

# 필요 항목만 추출하는 사용자 정의 함수 생성
getXmlText <- function(x, var) {
  result <- x %>% xml_node(var) %>% xml_text()
  return(result)
}
```

이제 새로 만든 사용자 정의 함수의 `x` 인자에는 `items`, `var` 인자에는 `bidNtceNo` 같은 태그를 (따옴표로 씌워서) 할당하면 해당 태그에 속한 텍스트를 벡터로 얻을 수 있습니다.

``` r
# 태그로 텍스트 데이터 얻기 예제
입찰공고번호 <- getXmlText(items, "bidNtceNo")
print(입찰공고번호)
```

    ## [1] "20171233674" "20171232329"

이렇게 얻은 각각의 텍스트 벡터들을 데이터 프레임으로 만들어 보겠습니다.

``` r
# 데이터 프레임으로 정리하기
df <- data.frame(
  공고번호 = getXmlText(items, "bidNtceNo"),
  입찰공고명 = getXmlText(items, "bidNtceNm"),
  참가업체수 = getXmlText(items, "prtcptCnum"),
  낙찰업체명 = getXmlText(items, "bidwinnrNm"),
  사업자번호 = getXmlText(items, "bidwinnrBizno"),
  대표자명   = getXmlText(items, "bidwinnrCeoNm"),
  업체주소   = getXmlText(items, "bidwinnrAdrs"),
  전화번호   = getXmlText(items, "bidwinnrTelNo"),
  낙찰금액   = getXmlText(items, "sucsfbidAmt")
)
```

위와 같이 함으로써 한 페이지에 보이는 XML을 데이터 프레임 형태로 저장할 수 있습니다.

만약 4,513건을 모두 수집하려면 어떻게 해야 할까요? url 요소 중 **한 페이지 결과 수**를 1,000으로 다시 지정하고 **페이지 번호**를 1~5까지 순환하며 반복실행하면 간단하게 해결될 것입니다.

그런데 가능한 모든 것을 자동화하는 것을 시도해보겠습니다. 일단 전체 제공 건수를 모른다고 가정하고 이 숫자를 확인한 후 페이지 수를 계산하는 코드를 만들어 봅시다.

``` r
# 전체 건수 확인
totalCnt <- read_xml(resp) %>% 
  xml_node("totalCount") %>% 
  xml_text() %>% 
  as.numeric()
print(totalCnt)
```

    ## [1] 4512

``` r
# 한 페이지당 노출 건수 재지정
rows <- 1000

# 한 페이지당 1,000개 노출 시 필요 페이지 수 계산
# ceiling()는 올림된 수를 반환하는 함수
pages <- ceiling(totalCnt / rows)
print(pages)
```

    ## [1] 5

이제 마지막으로 최종 결과 객체를 빈 데이터 프레임으로 생성한 후, `rbind()`만 해주면 끝입니다.

``` r
# 최종 결과 객체
compList <- data.frame()

# 순환 함수
for (i in 1:pages) {
  
  # url 조립. 페이지 부분을 i로 변경!
  url <- paste0(
    main,
    item,
    paste0("?ServiceKey=", key),
    paste0("&numOfRows=", rows),
    paste0("&pageNo=", i),
    paste0("&inqryDiv=", inqry),
    paste0("&inqryBgnDt=", bgnDate),
    paste0("&inqryEndDt=", endDate)
  )
  
  # url로 요청하기
  resp <- GET(url)
  
  # 반복되는 부분을 items 객체에 할당
  items <- read_xml(resp) %>% xml_nodes("item")
  
  # 데이터 프레임으로 정리하기
  df <- data.frame(
    공고번호   = getXmlText(items, "bidNtceNo"),
    입찰공고명 = getXmlText(items, "bidNtceNm"),
    참가업체수 = getXmlText(items, "prtcptCnum"),
    낙찰업체명 = getXmlText(items, "bidwinnrNm"),
    사업자번호 = getXmlText(items, "bidwinnrBizno"),
    대표자명   = getXmlText(items, "bidwinnrCeoNm"),
    업체주소   = getXmlText(items, "bidwinnrAdrs"),
    전화번호   = getXmlText(items, "bidwinnrTelNo"),
    낙찰금액   = getXmlText(items, "sucsfbidAmt")
  )
  
  # 행 기준 추가
  compList <- rbind(compList, df)
}
```

생성된 객체의 데이터 구조를 확인하겠습니다.

``` r
# 데이터 구조 확인하기
str(object = compList)
```

    ## 'data.frame':    4512 obs. of  9 variables:
    ##  $ 공고번호  : chr  "20171233674" "20171232329" "20171219328" "20171213601" ...
    ##  $ 입찰공고명: chr  "2018년 본청 공용차랑 유류 단가계약" "2018년도 보건환경연구원북부지원 실험분석용 특수가스 단가계약" "2018학년도 국제고등학교 교복(동복,하복)학교주관구매업체 선정입찰(2단계경쟁)공고" "2018학년도 광주제일고등학교 교복(동복, 하복) 학교주관구매 입찰 공고" ...
    ##  $ 참가업체수: chr  "2" "7" "2" "2" ...
    ##  $ 낙찰업체명: chr  "대창주유소" "동서산업가스" "스마트학생복서방,일곡점" "런던베이직(북구점)" ...
    ##  $ 사업자번호: chr  "4331200178" "7280200290" "4090354378" "4091208503" ...
    ##  $ 대표자명  : chr  "박병창" "손민호" "이병식" "이천호" ...
    ##  $ 업체주소  : chr  "경상북도 예천군 예천읍 충효로 154 대창주유소" "경상북도 영천시 도남공단1길 4-0 (도남동)" "광주광역시 북구 풍향동 496-24" "광주광역시 북구 독립로237번길 22-0 (누문동) 1,2층" ...
    ##  $ 전화번호  : chr  "054-654-2085" "054-334-2600" "062-511-1104" "062-526-5657" ...
    ##  $ 낙찰금액  : chr  "2849" "1000500" "285500" "280000" ...

이번에 생성한 데이터 프레임이 모두 4,513건, 9개 컬럼을 갖는 것으로 확인되었습니다.

이상으로 Open API를 활용한 공공데이터 수집을 소개해드렸습니다. 공공데이터 포털 뿐만 아니라 서울데이터광장, 금융감독원 및 한국은행 등 국가기관에서 다양한 데이터를 Open API로 공개하고 있으니 원하는 데이터가 있으면 손쉽게 수집하여 데이터 분석에 활용하시기 바랍니다!

[1] 궁금하신 분은 [여기](http://blog.koreadaily.com/view/myhome.html?fod_style=B&med_usrid=sam1&cid=901635&fod_no=16)를 방문해 보세요
