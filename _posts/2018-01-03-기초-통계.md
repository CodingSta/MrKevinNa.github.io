가장 기초적인 통계에 대해 간단하게 살펴보겠습니다.
--------------------------------------------------

-   데이터의 정규성을 확인합니다. (일부 알고리즘의 경우, 정규분포를 가정하기 때문입니다.)
-   기초 통계량을 구해봅니다.
    -   최소/최대, 4분위수, 중앙값, 평균, 분산, 표준편차 등
-   도수분포표를 구해봅니다.
    -   주어진 데이터를 일정 구간으로 나누고, 구간별 빈도수, 상대도수, 누적상대도수를 구합니다.
-   상자수염그림(Box plot)을 그리고 이상치를 확인합니다. 필요 시 NA로 변환하거나 삭제합니다.
-   히스토그램(Histgram)을 그려봅니다.
-   산점도(Scatter plot)를 그려봅니다.

정규성 테스트
-------------

-   회귀분석과 같은 알고리즘의 경우, 종속변수나 오차에 대해 정규분포를 가정하고 있으므로 분석 모델링을 하기에 앞서 데이터의 분포를 확인할 필요가 있습니다.

``` r
# 임의의 수를 생성할 때, 항상 같은 결과를 얻으려먼 set.seed() 함수를 이용합니다. 
set.seed(seed = 123)

# 평균이 0, 표준편차가 1인 정규분포를 따르는 임의의 수를 1000개 생성하여 x 객체에 할당합니다. 
x <- rnorm(n = 1000, mean = 0, sd = 1)
```

자료의 정규성을 그래프로 확인하는 방법은 크게 두 가지가 있습니다. 첫째, 히스토그램을 그려본다. 둘째, normal qq-plot을 그려본다

``` r
# R studio에서 한글을 사용하려면 par(family = "한글폰트")를 한 번 지정해주면 됩니다.
par(family = "NanumGothic")

# x의 분포를 확인하기 위해 히스토그램을 그려봅니다.
hist(x = x, 
     breaks = 10, 
     probability = TRUE, 
     main = "히스토그램 예제", 
     family = "NanumGothic")

# 히스트그램 위에 x의 확률밀도함수를 추가합니다.
lines(x = density(x), col = "red")
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-2-1.png?raw=true)

``` r
# 두 번째 방법으로는 단일분포의 normal qq-plot을 그려서 
# 직선인 경우 정규분포로 가정합니다.
qqnorm(y = x)
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-3-1.png?raw=true)

통계적 유의성 검정 방법도 두 가지를 예시로 들겠습니다.
첫째, Shapiro-Wilk 테스트가 있고,
둘째, Anderson-Darling 테스트가 있습니다.

이 두 가지 검증의 귀무가설은 "정규분포한다"이므로 p-value가 0.05보다 작으면 95% 유의수준 하에서 귀무가설을 기각할 수 있습니다.
아래 두 가지 검증 모두 p-value가 0.05보다 크므로 귀무가설을 기각할 수 없으므로 "정규분포한다"고 할 수 있습니다.

``` r
# Shapiro-Wilk test
library(stats)
shapiro.test(x = x)
```

    ## 
    ##  Shapiro-Wilk normality test
    ## 
    ## data:  x
    ## W = 0.99838, p-value = 0.4765

``` r
# Anderson-Darling test
library(nortest)
ad.test(x = x)
```

    ## 
    ##  Anderson-Darling normality test
    ## 
    ## data:  x
    ## A = 0.29653, p-value = 0.592

첨도(Kurtosis)와 왜도(Skewness) 확인

``` r
library(e1071)

# 정규분포의 경우, 첨도는 0에 가까운 값을 가집니다. 
# 0보다 작으면 완만하고, 0보다 크면 뾰족합니다.
kurtosis(x = x)
```

    ## [1] -0.08010201

``` r
# 정규분포의 경우, 왜도는 0에 가까운 값을 가집니다.
# 0보다 작으면 왼쪽 꼬리가 길고, 0보다 크면 그 반대입니다.
skewness(x = x)
```

    ## [1] 0.065196

기초 통계량 구하기
------------------

-   최소값(0%), 최대값(100%), 범위
-   중앙값(50%)
-   평균
-   사분위수 : 최소값, 1분위수(25%), 중앙값, 평균, 3분위수(75%), 최대값
-   사분범위(IQR) : 3분위수와 1분위수 간 범위
-   분산과 표준편차

``` r
# 최소값 : min()
cat("최소값 :", round(x = min(x), digits = 3), "\n")
```

    ## 최소값 : -2.81

``` r
# 중앙값: 
cat("중앙값 :", round(x = median(x), digits = 3), "\n")
```

    ## 중앙값 : 0.009

``` r
# 평균 : mean()
cat("평균   :", round(x = mean(x), digits = 3), "\n")
```

    ## 평균   : 0.016

``` r
# 최대값 : max()
cat("최대값 :", round(x = max(x), digits = 3), "\n")
```

    ## 최대값 : 3.241

``` r
# 범위 : range(), 최소값과 최대값을 한 번에 출력
cat("범위   :", round(x = range(x), digits = 3), "\n")
```

    ## 범위   : -2.81 3.241

``` r
# 분위수 : quantile()
cat("분위수 :", round(x = quantile(x), digits = 3), "\n")
```

    ## 분위수 : -2.81 -0.628 0.009 0.665 3.241

``` r
# 분위수의 %를 임의로 조정할 수 있습니다. 
qntl <- round(x = quantile(x = x, 
                           probs = c(0, 0.05, 0.1, 0.9, 0.95, 1)),
              digits = 3)
print(qntl)
```

    ##     0%     5%    10%    90%    95%   100% 
    ## -2.810 -1.623 -1.267  1.255  1.676  3.241

``` r
# 숫자형 데이터의 요약 통계량을 간단하게 확인할 수 있습니다. 
summary(object = x)
```

    ##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
    ## -2.80978 -0.62832  0.00921  0.01613  0.66460  3.24104

``` r
# 분산은 개별 x값에서 평균을 뺀 후 제곱하여 모두 더한 값을 n-1로 나눈 것입니다. 
cat("분산 :", round(x = var(x), digits = 4), "\n")
```

    ## 분산 : 0.9835

``` r
# 표준편차는 분산의 양의 제곱근입니다.
cat("표준편차 :", round(x = sd(x), digits = 4), "\n")
```

    ## 표준편차 : 0.9917

``` r
# 숫자형 데이터의 기술(descriptive) 통계량을 한 번에 확인할 수 있습니다.
psych::describe(x = x)
```

    ##    vars    n mean   sd median trimmed  mad   min  max range skew kurtosis
    ## X1    1 1000 0.02 0.99   0.01    0.01 0.96 -2.81 3.24  6.05 0.07    -0.08
    ##      se
    ## X1 0.03

위에서 열거한 기초 통계량을 모두 확인하는 사용자 정의 함수를 만들어 활용해보겠습니다.

``` r
myStats <- function(obj) {
    cat("최소값  :", round(x = min(obj), digits = 3), "\n")
    cat("1분위수 :", round(x = quantile(obj)[2], digits = 3), "\n")
    cat("중앙값  :", round(x = median(obj), digits = 3), "\n")
    cat("평균    :", round(x = mean(obj), digits = 3), "\n")
    cat("3분위수 :", round(x = quantile(obj)[4], digits = 3), "\n")
    cat("최대값  :", round(x = max(obj), digits = 3), "\n")
    cat("분산    :", round(x = var(obj), digits = 3), "\n")
    cat("표준편차 :", round(x = sd(obj), digits = 3), "\n")
}

# 임의의 수를 생성할 때 항상 같은 결과를 얻으려먼 set.seed() 함수를 사용합니다. 
# 함수 안에 같은 정수를 할당하면 늘 같은 결과를 얻습니다. 
set.seed(seed = 123)
y <- rnorm(n = 100, mean = 10, sd = 5)
myStats(y)
```

    ## 최소값  : -1.546 
    ## 1분위수 : 7.531 
    ## 중앙값  : 10.309 
    ## 평균    : 10.452 
    ## 3분위수 : 13.459 
    ## 최대값  : 20.937 
    ## 분산    : 20.831 
    ## 표준편차 : 4.564

상자 수염 그림 (Box plot)
-------------------------

-   상자 수염 그림은 숫자형 데이터의 요약 수치를 한 눈에 알아볼 수 있는 그래프입니다. ![상자수엽그림](http://cfile27.uf.tistory.com/image/2774654A52CE9A3618B7B3)
-   출처 : <http://analyticsstory.com/72>

``` r
# 상자수염그림을 그려봅니다.
boxplot(x = y)
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-13-1.png?raw=true)

상자수염그림을 통해 이상치(outlier)를 확인할 수 있습니다. 이상치 설명을 위해 임의로 이상치를 추가해 보도록 하겠습니다.

``` r
# 테스트용 이상치를 벡터 y 앞 뒤로 2개씩 추가합니다. 
y <- c(c(-12, -10), y, c(32, 34))
boxplot(x = y)
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-14-1.png?raw=true)

이상치 기준값을 산정할 때, IQR(interquantile range)을 사용합니다. IQR은 1분위수와 3분위수 사이의 범위를 의미합니다. 이상치는 1분위수에서 IQR의 1.5배보다 낮은 값 또는 3분위수에서 IQR의 1.5배보다 큰 값으로 정할 수 있습니다.

``` r
# 사분범위(IQR)는 다음과 같이 쉽게 계산할 수 있습니다. 
iqrY <- IQR(x = y)
print(iqrY)
```

    ## [1] 6.183555

``` r
# 사분위수 구하기 
quntY <- quantile(x = y)
print(quntY)
```

    ##         0%        25%        50%        75%       100% 
    ## -12.000000   7.421486  10.308782  13.605041  34.000000

``` r
# 이상치 기준값 : 1분위수에서 IQR의 1.5배보다 작은 값 또는 3분위수에서 IQR의 1.5배보다 큰 값

# 벡터 y의 개별 값이 아래 조건식을 만족하는지 여부에 따라서 TRUE 또는 FALSE로 출력됩니다. 
out1 <- quntY[2] - iqrY * 1.5
out2 <- quntY[4] + iqrY * 1.5

cat("이상치 기준점 1 :", out1, "\n")
```

    ## 이상치 기준점 1 : -1.853847

``` r
cat("이상치 기준점 2 :", out2, "\n")
```

    ## 이상치 기준점 2 : 22.88037

``` r
# 이상치인 판정된 값을 출력합니다. 
y[y < out1 | y > out2]
```

    ## [1] -12 -10  32  34

``` r
# 벡터 y에서 이상치의 위치를 출력합니다. 
loc <- which(y < out1 | y > out2)
print(loc)
```

    ## [1]   1   2 103 104

``` r
# 벡터 y에서 이상치를 NA로 변경합니다. 
y[loc] <- NA
print(y)
```

    ##   [1]         NA         NA  7.1976218  8.8491126 17.7935416 10.3525420
    ##   [7] 10.6464387 18.5753249 12.3045810  3.6746938  6.5657357  7.7716901
    ##  [13] 16.1204090 11.7990691 12.0038573 10.5534136  7.2207943 18.9345657
    ##  [19] 12.4892524  0.1669142 13.5067795  7.6360430  4.6608815  8.9101254
    ##  [25]  4.8699778  6.3555439  6.8748037  1.5665334 14.1889352 10.7668656
    ##  [31]  4.3093153 16.2690746 12.1323211  8.5246426 14.4756283 14.3906674
    ##  [37] 14.1079054 13.4432013 12.7695883  9.6904414  8.4701867  8.0976450
    ##  [43]  6.5264651  8.9604136  3.6730182 20.8447798 16.0398100  4.3844571
    ##  [49]  7.9855758  7.6667232 13.8998256  9.5831547 11.2665926  9.8572662
    ##  [55]  9.7856477 16.8430114  8.8711451 17.5823530  2.2562360 12.9230687
    ##  [61] 10.6192712 11.0797078 11.8981974  7.4883827  8.3339631  4.9071231
    ##  [67]  4.6410439 11.5176432 12.2410489 10.2650211 14.6113373 20.2504234
    ##  [73]  7.5448442 -1.5458444 15.0286926  6.4539962  6.5599569 15.1278568
    ##  [79]  8.5761350  3.8964114 10.9065174  9.3055432 10.0288209 11.9264020
    ##  [85]  8.1466998 13.2218827  8.8975672 11.6589098 15.4841951 12.1759075
    ##  [91]  8.3703421 15.7440381 14.9675193 12.7419848 11.1936587  6.8604696
    ##  [97] 16.8032622  6.9987021 20.9366650 17.6630531  8.8214982  4.8678955
    ## [103]         NA         NA

이상치를 삭제합니다.

``` r
# 이상치를 삭제합니다.
y1 <- y[complete.cases(y)]
length(y1)
```

    ## [1] 100

``` r
y2 <- y[is.na(y) == FALSE]
length(y2)
```

    ## [1] 100

``` r
# 두 객체의 교집합의 길이를 확인합니다. 
length(x = intersect(x = y1, y = y2))
```

    ## [1] 100

이상치를 찾는 더 쉬운 방법은 boxplot.stats() 함수를 이용하는 것입니다.

``` r
set.seed(seed = 123)
y <- rnorm(n = 100, mean = 10, sd = 5)
y <- c(c(-12, -10), y , c(32, 34))

# boxplot.stats() 함수의 결과 객체 중 out이 이상치를 제공합니다. 
boxplot.stats(x = y)
```

    ## $stats
    ## [1] -1.545844  7.354589 10.308782 13.703303 20.936665
    ## 
    ## $n
    ## [1] 104
    ## 
    ## $conf
    ## [1]  9.325164 11.292399
    ## 
    ## $out
    ## [1] -12 -10  32  34

``` r
# 이상치를 NA로 변경한 후 삭제합니다. 
y[y == boxplot.stats(y)$out] <- NA
print(y)
```

    ##   [1]         NA         NA  7.1976218  8.8491126 17.7935416 10.3525420
    ##   [7] 10.6464387 18.5753249 12.3045810  3.6746938  6.5657357  7.7716901
    ##  [13] 16.1204090 11.7990691 12.0038573 10.5534136  7.2207943 18.9345657
    ##  [19] 12.4892524  0.1669142 13.5067795  7.6360430  4.6608815  8.9101254
    ##  [25]  4.8699778  6.3555439  6.8748037  1.5665334 14.1889352 10.7668656
    ##  [31]  4.3093153 16.2690746 12.1323211  8.5246426 14.4756283 14.3906674
    ##  [37] 14.1079054 13.4432013 12.7695883  9.6904414  8.4701867  8.0976450
    ##  [43]  6.5264651  8.9604136  3.6730182 20.8447798 16.0398100  4.3844571
    ##  [49]  7.9855758  7.6667232 13.8998256  9.5831547 11.2665926  9.8572662
    ##  [55]  9.7856477 16.8430114  8.8711451 17.5823530  2.2562360 12.9230687
    ##  [61] 10.6192712 11.0797078 11.8981974  7.4883827  8.3339631  4.9071231
    ##  [67]  4.6410439 11.5176432 12.2410489 10.2650211 14.6113373 20.2504234
    ##  [73]  7.5448442 -1.5458444 15.0286926  6.4539962  6.5599569 15.1278568
    ##  [79]  8.5761350  3.8964114 10.9065174  9.3055432 10.0288209 11.9264020
    ##  [85]  8.1466998 13.2218827  8.8975672 11.6589098 15.4841951 12.1759075
    ##  [91]  8.3703421 15.7440381 14.9675193 12.7419848 11.1936587  6.8604696
    ##  [97] 16.8032622  6.9987021 20.9366650 17.6630531  8.8214982  4.8678955
    ## [103]         NA         NA

``` r
y <- y[complete.cases(y)]
length(x = y)
```

    ## [1] 100

표준화 vs 정규화
----------------

-   표준화(Standardization)와 정규화(Normalization)는 숫자형 데이터가 일정한 분포를 갖도록 변환하는 것을 의미합니다.
-   척도가 서로 다른 2개 이상의 숫자형 데이터를 그대로 사용하는 경우, 분석 모형이 각각의 척도에 영향을 받게 됩니다.
-   또한 인공신경망처럼 입력값이 0~1 사이의 값으로 요구되는 경우는 반드시 정규화를 해주어야 합니다.
-   표준화는 평균과 표준편차를 이용하여 변환하며, 표준화된 데이터(Z)는 -Inf과 Inf 사이의 값을 가집니다.
    -   x는 원본 데이터, μ는 x의 평균, σ는 x의 표준편차
        $$ Z = \\frac {x - \\mu} \\sigma $$
-   정규화는 0과 1 사이의 값을 갖도록 조정하는 것을 의미하며, 다양한 방법이 있으나 주로 최소값과 최대값을 이용하여 변환합니다.
    -   x는 원본 데이터, min은 x의 최소값, max는 x의 최대값
        $$ x\_{new} = \\frac {x - min} {max - min} $$

``` r
# 난수를 생성하기 전에 set.seed()를 지정합니다. 
set.seed(seed = 1)

# 1부터 1000의 값을 가지는 숫자형 벡터를 만들고, 그 중 500개를 임의로 선택하여 a 객체에 할당합니다.
a <- sample(x = 1:1000, size = 500, replace = FALSE, prob = NULL)
myStats(a)
```

    ## 최소값  : 1 
    ## 1분위수 : 256.75 
    ## 중앙값  : 522.5 
    ## 평균    : 515.306 
    ## 3분위수 : 766.25 
    ## 최대값  : 1000 
    ## 분산    : 84064.1 
    ## 표준편차 : 289.938

``` r
# 평균이 0, 표준편차가 1인 데이터로 표준화합니다. 
scaledA1 <- scale(x = a, center = mean(a), scale = sd(a))
myStats(scaledA1)
```

    ## 최소값  : -1.774 
    ## 1분위수 : -0.892 
    ## 중앙값  : 0.025 
    ## 평균    : 0 
    ## 3분위수 : 0.866 
    ## 최대값  : 1.672 
    ## 분산    : 1 
    ## 표준편차 : 1

``` r
# 최소값이 0, 최대값이 1인 데이터로 정규화합니다. 
scaledA2 <- scale(x = a, center = min(a), scale = (max(a) - min(a)))
myStats(scaledA2)
```

    ## 최소값  : 0 
    ## 1분위수 : 0.256 
    ## 중앙값  : 0.522 
    ## 평균    : 0.515 
    ## 3분위수 : 0.766 
    ## 최대값  : 1 
    ## 분산    : 0.084 
    ## 표준편차 : 0.29

도수분포표 만들기
-----------------

-   주어진 자료를 몇 개의 구간으로 나누고, 해당 구간에 속하는 자료의 개수(빈도수)를 구합니다.
-   빈도수에 상응하는 상대도수를 추가합니다.
-   빈도수와 상대도수의 합계를 구하여 추가합니다.

``` r
# 가상의 몸무게 데이터를 만듭니다.
set.seed(seed = 123)
weights <- rnorm(n = 100, mean = 70, sd = 10)
weights <- round(x = weights, digits = 1)

# 기초 통계량을 확인합니다.
myStats(weights)
```

    ## 최소값  : 46.9 
    ## 1분위수 : 65.075 
    ## 중앙값  : 70.6 
    ## 평균    : 70.901 
    ## 3분위수 : 76.925 
    ## 최대값  : 91.9 
    ## 분산    : 83.486 
    ## 표준편차 : 9.137

``` r
# 5kg 단위로 구간을 만들고, 빈도수를 구합니다.
# Hmisc::cut2() 함수의 minmax 인자는 최소값 또는 최대값을 포함할지 여부를 지정! 
cuts <- seq(from = 45, to = 90, by = 5)
weightsCuts <- Hmisc::cut2(x = weights, cuts = cuts, minmax = TRUE)
weightsTb <- table(weightsCuts)
print(weightsTb)
```

    ## weightsCuts
    ## [45.0,50.0) [50.0,55.0) [55.0,60.0) [60.0,65.0) [65.0,70.0) [70.0,75.0) 
    ##           1           3          10          10          24          21 
    ## [75.0,80.0) [80.0,85.0) [85.0,90.0) [90.0,91.9] 
    ##          14           9           5           3

``` r
# 각 구간별 상대도수를 구한 후, 도수분포표에 추가합니다.
weightsPr <- prop.table(x = weightsTb, margin = NULL)
weightsTb <- rbind(weightsTb, weightsPr)
print(weightsTb)
```

    ##           [45.0,50.0) [50.0,55.0) [55.0,60.0) [60.0,65.0) [65.0,70.0)
    ## weightsTb        1.00        3.00        10.0        10.0       24.00
    ## weightsPr        0.01        0.03         0.1         0.1        0.24
    ##           [70.0,75.0) [75.0,80.0) [80.0,85.0) [85.0,90.0) [90.0,91.9]
    ## weightsTb       21.00       14.00        9.00        5.00        3.00
    ## weightsPr        0.21        0.14        0.09        0.05        0.03

``` r
# 각 구간별 누적상대도수를 구한 후, 도수분포표에 추가합니다.
weightsCm <- cumsum(x = weightsPr)
weightsTb <- rbind(weightsTb, weightsCm)
print(weightsTb)
```

    ##           [45.0,50.0) [50.0,55.0) [55.0,60.0) [60.0,65.0) [65.0,70.0)
    ## weightsTb        1.00        3.00       10.00       10.00       24.00
    ## weightsPr        0.01        0.03        0.10        0.10        0.24
    ## weightsCm        0.01        0.04        0.14        0.24        0.48
    ##           [70.0,75.0) [75.0,80.0) [80.0,85.0) [85.0,90.0) [90.0,91.9]
    ## weightsTb       21.00       14.00        9.00        5.00        3.00
    ## weightsPr        0.21        0.14        0.09        0.05        0.03
    ## weightsCm        0.69        0.83        0.92        0.97        1.00

``` r
# 행별 합계를 구한 후, 도수분포표에 추가합니다.
weightsTb <- addmargins(A = weightsTb, margin = 2, FUN = sum)
print(weightsTb)
```

    ##           [45.0,50.0) [50.0,55.0) [55.0,60.0) [60.0,65.0) [65.0,70.0)
    ## weightsTb        1.00        3.00       10.00       10.00       24.00
    ## weightsPr        0.01        0.03        0.10        0.10        0.24
    ## weightsCm        0.01        0.04        0.14        0.24        0.48
    ##           [70.0,75.0) [75.0,80.0) [80.0,85.0) [85.0,90.0) [90.0,91.9]
    ## weightsTb       21.00       14.00        9.00        5.00        3.00
    ## weightsPr        0.21        0.14        0.09        0.05        0.03
    ## weightsCm        0.69        0.83        0.92        0.97        1.00
    ##              sum
    ## weightsTb 100.00
    ## weightsPr   1.00
    ## weightsCm   5.32

``` r
# 행과 열의 이름을 변경합니다.
rownames(weightsTb) <- c("빈도수(명)", "상대도수(%)", "누적상대도수(%)")
colnames(weightsTb) <- c("45~50kg", "50~55kg", "55~60kg", "60~65kg", "65~70kg",
                         "70~75kg", "75~80kg", "80~85kg", "85~90kg", "90kg이상", "합계")
print(weightsTb)
```

    ##                 45~50kg 50~55kg 55~60kg 60~65kg 65~70kg 70~75kg 75~80kg
    ## 빈도수(명)         1.00    3.00   10.00   10.00   24.00   21.00   14.00
    ## 상대도수(%)        0.01    0.03    0.10    0.10    0.24    0.21    0.14
    ## 누적상대도수(%)    0.01    0.04    0.14    0.24    0.48    0.69    0.83
    ##                 80~85kg 85~90kg 90kg이상   합계
    ## 빈도수(명)         9.00    5.00     3.00 100.00
    ## 상대도수(%)        0.09    0.05     0.03   1.00
    ## 누적상대도수(%)    0.92    0.97     1.00   5.32

히스토그램 그리기 (Histogram)
-----------------------------

> hist(x = x, breaks = 숫자, freq = TRUE, col = "색상명", labels = TRUE,
> xlim = c(시작점, 끝점), ylim = c(시작점, 끝점),
> xlab = "X축명", ylab = "Y축명", main = "전체 제목")

``` r
# 화면을 2행 * 2열로 나눕니다. 
par(mfrow = c(2, 2))

# 히스토그램을 그려봅니다. 
# 먼저 기본형을 그려봅니다. 
hist(x = y, main = "히스토그램 그리기", family = "NanumGothic")

# 빈도수 대신 상대도수를, 회색으로 출력합니다. 
hist(x = y, freq = FALSE, col = "gray50", border = "white", 
     xlab = "데이터", ylab = "상대도수", family = "NanumGothic")

# 막대의 개수를 15개로 늘리고, 상대도수를 함께 출력합니다. 
hist(x = y, labels = TRUE, breaks = 15, 
     freq = FALSE, col = "gray80", ylim = c(0, 0.1))

# 막대의 개수를 15개로 늘리고, 빈도수를 함께 출력합니다. 
hist(x = y, labels = TRUE, breaks = 15, 
     freq = TRUE, col = "blue", ylim = c(0, 20))
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-21-1.png?raw=true)

산점도 그리기 (Scatter plot)
----------------------------

> plot(x = x, y = y, type = "p",
> xlim = c(시작점, 끝점), ylim = c(시작점, 끝점),
> xlab = "X축명", ylab = "Y축명", main = "전체 제목")

``` r
# 1~200 값 중 150개씩 임의의 숫자를 갖도록 a, b 객체를 생성합니다. 
a <- sample(x = 1:200, size = 150, replace = FALSE, prob = NULL)
b <- sample(x = 1:200, size = 150, replace = FALSE, prob = NULL)

# a, b 객체로 산점도를 그립니다. 
plot(x = a, y = b, type = "p", 
     xlim = c(0, 200), ylim = c(0, 200), 
     xlab = "X축", ylab = "Y축", 
     main = "산점도 그리기", family = "NanumGothic")
```

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/unnamed-chunk-22-1.png?raw=true)
